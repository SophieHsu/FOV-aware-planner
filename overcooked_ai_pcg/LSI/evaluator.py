"""Defines a Ray remote function for running evaluations."""
import resource

from dask.distributed import get_worker
from overcooked_ai_pcg.GAN_training import dcgan
from overcooked_ai_pcg.gen_lvl import generate_lvl
from overcooked_ai_pcg.helper import run_overcooked_game
from overcooked_ai_pcg.LSI import bc_calculate


def print_mem_usage(info, worker_id):
    print(f"worker({worker_id}): Memory usage ({info}):",
          resource.getrusage(resource.RUSAGE_SELF).ru_maxrss)


def run_overcooked_eval(ind, visualize, elite_map_config, G_params,
        gan_state_dict, worker_id):
    """
    Evaluates overcooked game by running a game and calculating relevant BC's.

    Args:
        ind (overcooked_ai_pcg.LSI.qd_algorithms.Individual): Individual
            generated by the algorithm for evaluate.
        visualize (bool): render the game(evaluation) or not
        worker_id (int): Worker ID to use.

    Returns:
        The individual that was passed in (ind), but with populated data fields.
    """
    print_mem_usage("start", worker_id)
    dask_worker = get_worker()

    # these values are set in set_gan_data in run_search.py
    #  elite_map_config = dask_worker.data["elite_map_config"]
    #  G_params = dask_worker.data["G_params"]
    #  gan_state_dict = dask_worker.data["gan_state_dict"]

    generator = dcgan.DCGAN_G(**G_params)
    generator.load_state_dict(gan_state_dict)

    print_mem_usage("after loading GAN", worker_id)

    # generate new level
    ind.level = generate_lvl(
        1,
        generator,
        # since this vector originates from the algorithm actor, it may be
        # read-only; we copy it so generate_lvl can do whatever it wants with it
        ind.param_vector.copy(),
        worker_id=worker_id,
    )
    # ind.level = generate_rnd_lvl((6, 8), worker_id=self.id)

    print_mem_usage("after generating level", worker_id)

    # run simulation
    try:
        ind.fitness, ind.score, ind.timestep, ind.player_workload = run_overcooked_game(
            ind.level, render=visualize, worker_id=worker_id)
    except TimeoutError:
        print(
            "worker(%d): Level generated taking too much time to plan. Skipping"
            % worker_id)
        return None

    print_mem_usage("after running overcooked game", worker_id)

    # calculate bc out of the game
    ind.features = []
    for bc in elite_map_config["Map"]["Features"]:
        # get the function that calculates bc
        bc_fn_name = bc["name"]
        bc_fn = getattr(bc_calculate, bc_fn_name)
        bc_val = bc_fn(ind)
        ind.features.append(bc_val)
    ind.features = tuple(ind.features)
    print("worker(%d): Game end; fitness = %d" % (worker_id, ind.fitness))

    print_mem_usage("end", worker_id)

    return ind
