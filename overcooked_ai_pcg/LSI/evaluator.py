"""Defines a Ray remote function for running evaluations."""
import resource

from overcooked_ai_pcg.GAN_training import dcgan
from overcooked_ai_pcg.gen_lvl import generate_lvl
from overcooked_ai_pcg.helper import run_overcooked_game
from overcooked_ai_pcg.LSI import bc_calculate

import gc

def print_mem_usage(info, worker_id):
    print(f"worker({worker_id}): Memory usage ({info}):",
          resource.getrusage(resource.RUSAGE_SELF).ru_maxrss)


def run_overcooked_eval(ind, visualize, elite_map_config, agent_config, G_params,
                        gan_state_dict, worker_id):
    """
    Evaluates overcooked game by running a game and calculating relevant BC's.

    Args:
        ind (overcooked_ai_pcg.LSI.qd_algorithms.Individual): Individual
            generated by the algorithm for evaluate.
        visualize (bool): render the game(evaluation) or not
        elite_map_config: toml config object of the feature maps
        G_params: parameters for the GAN
        gan_state_dict: weights of the GAN
        worker_id (int): Worker ID to use.

    Returns:
        The individual that was passed in (ind), but with populated data fields.
    """
    print_mem_usage("start", worker_id)

    generator = dcgan.DCGAN_G(**G_params)
    generator.load_state_dict(gan_state_dict)

    print_mem_usage("after loading GAN", worker_id)

    # generate new level
    ind.level = generate_lvl(
        1,
        generator,
        # since this vector originates from the algorithm actor, Ray makes it
        # read-only; thus, we should copy it so generate_lvl can do whatever it
        # wants with it
        ind.param_vector[:32].copy(),
        worker_id=worker_id,
    )
    # ind.level = generate_rnd_lvl((6, 8), worker_id=self.id)

    # generate human worker preference and adaptiveness
    ind.human_preference = ind.param_vector[32]
    ind.human_adaptiveness = ind.param_vector[33]
    # print('human parameters =', ind.human_preference, ind.human_adaptiveness)

    del generator

    print_mem_usage("after generating level", worker_id)

    # run simulation
    try:
        ind.fitness, ind.score, ind.timestep, ind.player_workload = run_overcooked_game(ind, ind.level, agent_config, render=visualize, worker_id=worker_id)
    except TimeoutError:
        print(
            "worker(%d): Level generated taking too much time to plan. Skipping"
            % worker_id)
        return None

    print_mem_usage("after running overcooked game", worker_id)
    
    # calculate bc out of the game
    ind.features = []
    for bc in elite_map_config["Map"]["Features"]:
        # get the function that calculates bc
        bc_fn_name = bc["name"]
        bc_fn = getattr(bc_calculate, bc_fn_name)
        bc_val = bc_fn(ind)
        ind.features.append(bc_val)
    ind.features = tuple(ind.features)
    print("worker(%d): Game end; fitness = %d" % (worker_id, ind.fitness))

    print_mem_usage("end", worker_id)
    gc.collect()
    return ind
